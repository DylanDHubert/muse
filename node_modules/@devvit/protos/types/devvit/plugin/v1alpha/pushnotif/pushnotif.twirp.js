import { TwirpServer, TwirpError, TwirpErrorCode, TwirpContentType, chainInterceptors, } from 'twirp-ts';
import { QueuePushNotificationRequest, QueuePushNotificationResponse, BulkQueuePushNotificationRequest, BulkQueuePushNotificationResponse, OptInCurrentUserResponse, OptOutCurrentUserResponse, ListOptedInUsersRequest, ListOptedInUsersResponse, } from './pushnotif.js';
import { Empty } from '../../../../google/protobuf/empty.js';
export var PushNotifMethod;
(function (PushNotifMethod) {
    PushNotifMethod["QueuePushNotification"] = "QueuePushNotification";
    PushNotifMethod["BulkQueuePushNotification"] = "BulkQueuePushNotification";
    PushNotifMethod["OptInCurrentUser"] = "OptInCurrentUser";
    PushNotifMethod["OptOutCurrentUser"] = "OptOutCurrentUser";
    PushNotifMethod["ListOptedInUsers"] = "ListOptedInUsers";
})(PushNotifMethod || (PushNotifMethod = {}));
export const PushNotifMethodList = [
    PushNotifMethod.QueuePushNotification,
    PushNotifMethod.BulkQueuePushNotification,
    PushNotifMethod.OptInCurrentUser,
    PushNotifMethod.OptOutCurrentUser,
    PushNotifMethod.ListOptedInUsers,
];
export function createPushNotifServer(service) {
    return new TwirpServer({
        service,
        packageName: 'devvit.plugin.v1alpha.pushnotif',
        serviceName: 'PushNotif',
        methodList: PushNotifMethodList,
        matchRoute: matchPushNotifRoute,
    });
}
function matchPushNotifRoute(method, events) {
    switch (method) {
        case 'QueuePushNotification':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'QueuePushNotification' };
                await events.onMatch(ctx);
                return handlePushNotifQueuePushNotificationRequest(ctx, service, data, interceptors);
            };
        case 'BulkQueuePushNotification':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'BulkQueuePushNotification' };
                await events.onMatch(ctx);
                return handlePushNotifBulkQueuePushNotificationRequest(ctx, service, data, interceptors);
            };
        case 'OptInCurrentUser':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OptInCurrentUser' };
                await events.onMatch(ctx);
                return handlePushNotifOptInCurrentUserRequest(ctx, service, data, interceptors);
            };
        case 'OptOutCurrentUser':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'OptOutCurrentUser' };
                await events.onMatch(ctx);
                return handlePushNotifOptOutCurrentUserRequest(ctx, service, data, interceptors);
            };
        case 'ListOptedInUsers':
            return async (ctx, service, data, interceptors) => {
                ctx = { ...ctx, methodName: 'ListOptedInUsers' };
                await events.onMatch(ctx);
                return handlePushNotifListOptedInUsersRequest(ctx, service, data, interceptors);
            };
        default:
            events.onNotFound();
            const msg = `no handler found`;
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handlePushNotifQueuePushNotificationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handlePushNotifQueuePushNotificationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handlePushNotifQueuePushNotificationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handlePushNotifBulkQueuePushNotificationRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handlePushNotifBulkQueuePushNotificationJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handlePushNotifBulkQueuePushNotificationProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handlePushNotifOptInCurrentUserRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handlePushNotifOptInCurrentUserJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handlePushNotifOptInCurrentUserProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handlePushNotifOptOutCurrentUserRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handlePushNotifOptOutCurrentUserJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handlePushNotifOptOutCurrentUserProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
function handlePushNotifListOptedInUsersRequest(ctx, service, data, interceptors) {
    switch (ctx.contentType) {
        case TwirpContentType.JSON:
            return handlePushNotifListOptedInUsersJSON(ctx, service, data, interceptors);
        case TwirpContentType.Protobuf:
            return handlePushNotifListOptedInUsersProtobuf(ctx, service, data, interceptors);
        default:
            const msg = 'unexpected Content-Type';
            throw new TwirpError(TwirpErrorCode.BadRoute, msg);
    }
}
async function handlePushNotifQueuePushNotificationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = QueuePushNotificationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.QueuePushNotification(ctx, inputReq);
        });
    }
    else {
        response = await service.QueuePushNotification(ctx, request);
    }
    return JSON.stringify(QueuePushNotificationResponse.toJSON(response));
}
async function handlePushNotifBulkQueuePushNotificationJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = BulkQueuePushNotificationRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.BulkQueuePushNotification(ctx, inputReq);
        });
    }
    else {
        response = await service.BulkQueuePushNotification(ctx, request);
    }
    return JSON.stringify(BulkQueuePushNotificationResponse.toJSON(response));
}
async function handlePushNotifOptInCurrentUserJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Empty.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OptInCurrentUser(ctx, inputReq);
        });
    }
    else {
        response = await service.OptInCurrentUser(ctx, request);
    }
    return JSON.stringify(OptInCurrentUserResponse.toJSON(response));
}
async function handlePushNotifOptOutCurrentUserJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = Empty.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OptOutCurrentUser(ctx, inputReq);
        });
    }
    else {
        response = await service.OptOutCurrentUser(ctx, request);
    }
    return JSON.stringify(OptOutCurrentUserResponse.toJSON(response));
}
async function handlePushNotifListOptedInUsersJSON(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        const body = JSON.parse(data.toString() || '{}');
        request = ListOptedInUsersRequest.fromJSON(body);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the json request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ListOptedInUsers(ctx, inputReq);
        });
    }
    else {
        response = await service.ListOptedInUsers(ctx, request);
    }
    return JSON.stringify(ListOptedInUsersResponse.toJSON(response));
}
async function handlePushNotifQueuePushNotificationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = QueuePushNotificationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.QueuePushNotification(ctx, inputReq);
        });
    }
    else {
        response = await service.QueuePushNotification(ctx, request);
    }
    return Buffer.from(QueuePushNotificationResponse.encode(response).finish());
}
async function handlePushNotifBulkQueuePushNotificationProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = BulkQueuePushNotificationRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.BulkQueuePushNotification(ctx, inputReq);
        });
    }
    else {
        response = await service.BulkQueuePushNotification(ctx, request);
    }
    return Buffer.from(BulkQueuePushNotificationResponse.encode(response).finish());
}
async function handlePushNotifOptInCurrentUserProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Empty.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OptInCurrentUser(ctx, inputReq);
        });
    }
    else {
        response = await service.OptInCurrentUser(ctx, request);
    }
    return Buffer.from(OptInCurrentUserResponse.encode(response).finish());
}
async function handlePushNotifOptOutCurrentUserProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = Empty.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.OptOutCurrentUser(ctx, inputReq);
        });
    }
    else {
        response = await service.OptOutCurrentUser(ctx, request);
    }
    return Buffer.from(OptOutCurrentUserResponse.encode(response).finish());
}
async function handlePushNotifListOptedInUsersProtobuf(ctx, service, data, interceptors) {
    let request;
    let response;
    try {
        request = ListOptedInUsersRequest.decode(data);
    }
    catch (e) {
        if (e instanceof Error) {
            const msg = 'the protobuf request could not be decoded';
            throw new TwirpError(TwirpErrorCode.Malformed, msg).withCause(e, true);
        }
    }
    if (interceptors && interceptors.length > 0) {
        const interceptor = chainInterceptors(...interceptors);
        response = await interceptor(ctx, request, (ctx, inputReq) => {
            return service.ListOptedInUsers(ctx, inputReq);
        });
    }
    else {
        response = await service.ListOptedInUsers(ctx, request);
    }
    return Buffer.from(ListOptedInUsersResponse.encode(response).finish());
}
