import type { RedisClient } from '@devvit/redis';
import type { JsonValue } from '@devvit/shared-types/json.js';
export type CacheEntry = {
    value: JsonValue | null;
    expires: number;
    error: string | null;
    errorTime: number | null;
    checkedAt: number;
    errorCount: number;
};
/**
 * A class that provides a random number between 0 and 1. It is helpful to extract this for testing purposes.
 */
export type Randomizer = {
    random(): number;
};
export declare const MathRandomizer: Randomizer;
/**
 * A class that provides the current time. It is helpful to extract this for testing purposes.
 */
export type Clock = {
    now(): Date;
};
export declare const SystemClock: Clock;
export type CacheOptions = {
    /**
     * Time to live in seconds.
     */
    ttl: number;
    /**
     * Key to use for caching.
     */
    key: string;
};
export type LocalCache = {
    [key: string]: CacheEntry;
};
export declare function _namespaced(key: string): string;
export declare function _lock(key: string): string;
export declare const retryLimit: number;
export declare const clientRetryDelay: number;
export declare const allowStaleFor: number;
/**
 * This class is responsible for managing the caching of promises. It is a layered cache, meaning it will first check
 * the local in-memory cache, then the redis cache, and finally the source of truth. It will also handle refreshing the cache according
 * to the TTL and error handling.
 *
 * The local cache is shared across all requests to a given pod, while the redis cache is shared across all requests to all pods.
 *
 * Please note that in order to prevent a stampede of requests to the source of truth, we use a lock in redis to ensure only one
 * request is made to the source of truth at a time. If the lock is obtained, the cache will be updated and the lock will be released.
 *
 * Additionally, we use a polling mechanism to fetch the cache if the lock is not obtained. This is to prevent unnecessary errors.
 *
 * Finally, we also want to prevent stampedes against redis for the lock election and the retries. We use a ramping probability to ease in the
 * attempts to get the lock, and not every error will trigger a retry.
 *
 * This means that the cache will be eventually consistent, but will not be immediately consistent. This is a tradeoff we are willing to make.
 * Additionally, this means that the TTL is not precise. The cache may be updated a bit more often than the TTL, but it will not be updated less often.
 *
 * @example
 * ```tsx
 *   import { cache, reddit } from "@devvit/web/server";
 *   export function fetchSnoovatarUrl(username: string): Promise<string> {
 *     return await cache(
 *       async () => {
 *         const url = await reddit.getSnoovatarUrl(username)
 *         console.log(`snoovatar URL cache busted for ${username}`)
 *         if (!url) {
 *           throw new Error(`Failed to fetch snoovatar URL for user ${username}`);
 *         }
 *         return url;
 *       },
 *       {
 *         key: `snoovatar_by_${username}`,
 *         ttl: 24 * 60 * 60 * 1000 // expire after one day.
 *       }
 *     );
 *   }
 * ```
 */
export declare class PromiseCache {
    #private;
    constructor(redis: RedisClient, localCache: LocalCache, clock: Clock, randomizer: Randomizer);
    cache<T extends JsonValue>(closure: () => Promise<T>, options: CacheOptions): Promise<T>;
}
//# sourceMappingURL=PromiseCache.d.ts.map