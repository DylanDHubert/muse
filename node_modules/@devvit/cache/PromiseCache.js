var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PromiseCache_instances, _PromiseCache_redis, _PromiseCache_localCache, _PromiseCache_clock, _PromiseCache_randomizer, _PromiseCache_localCachedAnswer, _PromiseCache_maybeRefreshCache, _PromiseCache_refreshCache, _PromiseCache_pollForCache, _PromiseCache_updateCache, _PromiseCache_calculateRamp, _PromiseCache_redisEntry;
// Isolate the random() method to avoid passing the Math package around
export const MathRandomizer = {
    random() {
        return Math.random();
    },
};
export const SystemClock = {
    now() {
        return new Date();
    },
};
export function _namespaced(key) {
    return `__devvit_cache_val__${key}`;
}
export function _lock(key) {
    return `__devvit_cache_lock__${key}`;
}
const minTtlMsValue = 5000; // milliseconds
const pollEvery = 300; // milliseconds
const maxPollingTimeout = 1000; // milliseconds
export const retryLimit = 3;
const errorRetryProbability = 0.1;
export const clientRetryDelay = 1000; // milliseconds
export const allowStaleFor = 30000; // milliseconds
function _unwrap(entry) {
    if (entry.error) {
        throw new Error(entry.error);
    }
    return entry.value;
}
/**
 * This class is responsible for managing the caching of promises. It is a layered cache, meaning it will first check
 * the local in-memory cache, then the redis cache, and finally the source of truth. It will also handle refreshing the cache according
 * to the TTL and error handling.
 *
 * The local cache is shared across all requests to a given pod, while the redis cache is shared across all requests to all pods.
 *
 * Please note that in order to prevent a stampede of requests to the source of truth, we use a lock in redis to ensure only one
 * request is made to the source of truth at a time. If the lock is obtained, the cache will be updated and the lock will be released.
 *
 * Additionally, we use a polling mechanism to fetch the cache if the lock is not obtained. This is to prevent unnecessary errors.
 *
 * Finally, we also want to prevent stampedes against redis for the lock election and the retries. We use a ramping probability to ease in the
 * attempts to get the lock, and not every error will trigger a retry.
 *
 * This means that the cache will be eventually consistent, but will not be immediately consistent. This is a tradeoff we are willing to make.
 * Additionally, this means that the TTL is not precise. The cache may be updated a bit more often than the TTL, but it will not be updated less often.
 *
 * @example
 * ```tsx
 *   import { cache, reddit } from "@devvit/web/server";
 *   export function fetchSnoovatarUrl(username: string): Promise<string> {
 *     return await cache(
 *       async () => {
 *         const url = await reddit.getSnoovatarUrl(username)
 *         console.log(`snoovatar URL cache busted for ${username}`)
 *         if (!url) {
 *           throw new Error(`Failed to fetch snoovatar URL for user ${username}`);
 *         }
 *         return url;
 *       },
 *       {
 *         key: `snoovatar_by_${username}`,
 *         ttl: 24 * 60 * 60 * 1000 // expire after one day.
 *       }
 *     );
 *   }
 * ```
 */
export class PromiseCache {
    constructor(redis, localCache, clock, randomizer) {
        _PromiseCache_instances.add(this);
        _PromiseCache_redis.set(this, void 0);
        _PromiseCache_localCache.set(this, void 0);
        _PromiseCache_clock.set(this, void 0);
        _PromiseCache_randomizer.set(this, void 0);
        __classPrivateFieldSet(this, _PromiseCache_redis, redis, "f");
        __classPrivateFieldSet(this, _PromiseCache_localCache, localCache, "f");
        __classPrivateFieldSet(this, _PromiseCache_clock, clock, "f");
        __classPrivateFieldSet(this, _PromiseCache_randomizer, randomizer, "f");
    }
    /*
     * Main entry point for caching a promise.  This will first check the local cache, then the redis cache, and finally
     * call the provided closure to get the value.  It will also handle refreshing the cache according to the TTL and error handling.
     *
     * When interacting with redis, this method may run:
     * - GET __autocache__${key} to get the cached value for a given key
     * - SET __autocache__${key} ${value} to set the cached value for a given key
     * - SET __lock__${key} '1' and DEL __lock__${key} to acquire and release a lock for a given key
     */
    async cache(closure, options) {
        const { key } = options;
        let ttlMs = options.ttl * 1000; // convert to milliseconds without mutating the original options object
        if (ttlMs < minTtlMsValue) {
            console.warn(`Cache TTL cannot be less than ${minTtlMsValue / 1000} seconds! Updating ttl value to ${minTtlMsValue / 1000} seconds.`);
            ttlMs = minTtlMsValue;
        }
        const localCachedAnswer = __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_localCachedAnswer).call(this, key);
        if (localCachedAnswer !== undefined) {
            return localCachedAnswer;
        }
        const existing = await __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_redisEntry).call(this, key);
        const entry = await __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_maybeRefreshCache).call(this, key, ttlMs, existing, closure);
        return _unwrap(entry);
    }
}
_PromiseCache_redis = new WeakMap(), _PromiseCache_localCache = new WeakMap(), _PromiseCache_clock = new WeakMap(), _PromiseCache_randomizer = new WeakMap(), _PromiseCache_instances = new WeakSet(), _PromiseCache_localCachedAnswer = function _PromiseCache_localCachedAnswer(key) {
    const val = __classPrivateFieldGet(this, _PromiseCache_localCache, "f")[key];
    if (val) {
        const now = __classPrivateFieldGet(this, _PromiseCache_clock, "f").now().getTime();
        const hasRetryableError = val?.error &&
            val?.errorTime &&
            val.errorCount < retryLimit &&
            __classPrivateFieldGet(this, _PromiseCache_randomizer, "f").random() < errorRetryProbability &&
            val.errorTime + clientRetryDelay < now;
        const expired = val?.expires && val.expires < now && val.checkedAt + clientRetryDelay < now;
        if (expired || hasRetryableError) {
            delete __classPrivateFieldGet(this, _PromiseCache_localCache, "f")[key];
            return undefined;
        }
        else {
            return _unwrap(val);
        }
    }
    return undefined;
}, _PromiseCache_maybeRefreshCache = 
/**
 * If we've bothered to check redis, we're already on the backend.  Let's see if the cache either (1) contains an error, (2)
 * is expired, (3) is missing, or (4) is about to expire.  If any of these are true, we'll refresh the cache based on heuristics.
 *
 * We'll always refresh if missing or expired, but its probabilistic if we'll refresh if about to expire or if we have an error.
 */
async function _PromiseCache_maybeRefreshCache(key, ttlMs, entry, closure) {
    const expires = entry?.expires;
    const rampProbability = expires ? __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_calculateRamp).call(this, expires) : 1;
    if (!entry ||
        (entry?.error &&
            entry.errorCount < retryLimit &&
            errorRetryProbability > __classPrivateFieldGet(this, _PromiseCache_randomizer, "f").random()) ||
        rampProbability > __classPrivateFieldGet(this, _PromiseCache_randomizer, "f").random()) {
        return __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_refreshCache).call(this, key, ttlMs, entry, closure);
    }
    else {
        return entry;
    }
}, _PromiseCache_refreshCache = 
/**
 * The conditions for refreshing the cache are handled in the calling method, which should be
 * #maybeRefreshCache.
 *
 * If you don't win the lock, you'll poll for the cache.  If you don't get the cache within maxPollingTimeout, you'll throw an error.
 */
async function _PromiseCache_refreshCache(key, ttlMs, entry, closure) {
    const lockKey = _lock(key);
    const now = __classPrivateFieldGet(this, _PromiseCache_clock, "f").now().getTime();
    /**
     * The write lock should last for a while, but not the full TTL.  Hopefully write attempts settle down after a while.
     */
    const lockExpiration = new Date(now + ttlMs / 2);
    const lockObtained = await __classPrivateFieldGet(this, _PromiseCache_redis, "f").set(lockKey, '1', {
        expiration: lockExpiration,
        nx: true,
    });
    if (lockObtained) {
        return __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_updateCache).call(this, key, entry, closure, ttlMs);
    }
    else if (entry) {
        // This entry is still valid, return it
        return entry;
    }
    else {
        const start = __classPrivateFieldGet(this, _PromiseCache_clock, "f").now();
        return __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_pollForCache).call(this, start, key, ttlMs);
    }
}, _PromiseCache_pollForCache = async function _PromiseCache_pollForCache(start, key, ttlMs) {
    const pollingTimeout = Math.min(ttlMs, maxPollingTimeout);
    const existing = await __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_redisEntry).call(this, key);
    if (existing) {
        return existing;
    }
    if (__classPrivateFieldGet(this, _PromiseCache_clock, "f").now().getTime() - start.getTime() >= pollingTimeout) {
        throw new Error(`Cache request timed out trying to get data at key: ${key}`);
    }
    await new Promise((resolve) => setTimeout(resolve, pollEvery));
    return __classPrivateFieldGet(this, _PromiseCache_instances, "m", _PromiseCache_pollForCache).call(this, start, key, ttlMs);
}, _PromiseCache_updateCache = 
/**
 * Actually update the cache.  This is the method that will be called if we have the lock.
 */
async function _PromiseCache_updateCache(key, entry, closure, ttlMs) {
    const expires = __classPrivateFieldGet(this, _PromiseCache_clock, "f").now().getTime() + ttlMs;
    entry = entry ?? {
        value: null,
        expires,
        errorCount: 0,
        error: null,
        errorTime: null,
        checkedAt: 0,
    };
    try {
        entry.value = await closure();
        entry.error = null;
        entry.errorCount = 0;
        entry.errorTime = null;
    }
    catch (err) {
        entry.value = null;
        entry.error = err instanceof Error ? err.message : 'unknown error';
        entry.errorTime = __classPrivateFieldGet(this, _PromiseCache_clock, "f").now().getTime();
        entry.errorCount++;
    }
    __classPrivateFieldGet(this, _PromiseCache_localCache, "f")[key] = entry;
    await __classPrivateFieldGet(this, _PromiseCache_redis, "f").set(_namespaced(key), JSON.stringify(entry), {
        expiration: new Date(expires + allowStaleFor),
    });
    /**
     * Unlocking will allow retries to happen if there was an error.  Otherwise we don't unlock, because the lock
     * will expire on its own.
     */
    if (entry.error && entry.errorCount < retryLimit) {
        await __classPrivateFieldGet(this, _PromiseCache_redis, "f").del(_lock(key));
    }
    return entry;
}, _PromiseCache_calculateRamp = function _PromiseCache_calculateRamp(expiry) {
    const now = __classPrivateFieldGet(this, _PromiseCache_clock, "f").now().getTime();
    const remaining = expiry - now;
    if (remaining < 0) {
        return 1;
    }
    else if (remaining < 1000) {
        return 0.1;
    }
    else if (remaining < 2000) {
        return 0.01;
    }
    else if (remaining < 3000) {
        return 0.001;
    }
    else {
        return 0;
    }
}, _PromiseCache_redisEntry = async function _PromiseCache_redisEntry(key) {
    const val = await __classPrivateFieldGet(this, _PromiseCache_redis, "f").get(_namespaced(key));
    if (val) {
        const entry = JSON.parse(val);
        entry.checkedAt = __classPrivateFieldGet(this, _PromiseCache_clock, "f").now().getTime();
        __classPrivateFieldGet(this, _PromiseCache_localCache, "f")[key] = entry;
        return entry;
    }
    return undefined;
};
